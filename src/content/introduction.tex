%----------------------------------------------------------------------------
\chapter{\bevezetes}
%----------------------------------------------------------------------------

Subgraph isomorphism is an NP-hard problem which has many application areas.
It is called substructure search in cheminformatics and it is used to find
similar molecular compounds based on their structural formula. In bioinformatics,
complex biological systems are decomposed into several different networks,
such as protein-protein interaction, metabolic interaction or hormone signaling
networks, which are represented as graphs. Analyzing and understanding these
large networks requires finding certain topological patterns, i.e. subgraph
isomorphism. 

Graph pattern matching is also a core concept of social network analysis.
Such graphs tend to be extremely large with millions of vertices and billions
of edges in the real world. Although subgraph isomorphism has been extensively
studied in the past, there was a renewed interest in the topic recently, which
yielded some notable results. The newer algorithms significantly out-perform
the previous state-of-the-art solutions \todo{ullman, vf2}, sometimes even 
in order of magnitudes. This made it possible to query subgraph isomorphisms
in such large graphs. However social networks are not static. In practice, they
are frequently updated with typically small changes like adding or removing edges.
Despite the changes being small, they will still have an impact on the matches.
This means that the matches have to be re-computed from scratch on every update,
which is highly infeasible even with the newer and faster subgraph isomorphism
algorithms. To minimize unnecessary re-computations, incremental algorithms
can be used, that compute the changes in matches based on the changes in the
search graph.

[] \todo{cite \url{https://www.pure.ed.ac.uk/ws/portalfiles/portal/17894104/Fan_Li_ET_AL_2011_Incremental_Graph_Pattern_Matching.pdf}}
discusses in depth several types of incremental graph pattern matching algorithms.
However the authors' topic of interest in [] is incremental graph pattern matching
with (bounded) graph simulation. A graph \(G\) matches a pattern \(q\) via graph 
simulation if there exists a binary relation \(S \subseteq V_q \times V\) such that 
\begin{enumerate}
    \item for each \(u \in V_q\), there exists \(v \in V\) such that \((u, v) \in S\);
    \item for each \((u, v) \in S\), 
        \begin{enumerate}
            \item \(\mathcal{L}(u) = \mathcal{L}(v)\), and
            \item for each edge \((u, u') \in E_q\), there exists a non-empty path \(\rho = v \rightsquigarrow v'\) in \(G\) such that \((u', v') \in S\) and the length of \(\rho\) is less than the maximum allowed length defined on the given edge in \(q\).
        \end{enumerate}
\end{enumerate}
Graph simulation is less strict about the topology of its results than graph
isomorphism. This can be beneficial if we want to express loose connections in
our query patterns, and on top of that, pattern matching with graph simulation
can be done in \(\mathcal{O}(n^3)\). However if we do require strict matches,
only subgraph isomorphism can come into play. Although the authors provided an
incremental algorithm for subgraph isomorphism, it was more of a demonstration
that even in an NP-hard case, computing matches incrementally (which is also
NP-hard) can out-perform a fast solution, VF2. The approach introduced there
does not take full advantage on previous computations, and it was also not 
evaluated in much detail. Note that this was not the main focus of the paper.

In this work, we investigate how two state-of-the-art algorithms (VF2++, DAF)
can be converted into their incremental version. First, we give an introduction
how the two algorithms work. Then we describe a method to make them incremental.
Finally, we evaluate the results both in terms of complexity and practical
measurements.

\section{Background}

\begin{definition}[Graph]
    A graph is a pair \(G = (V,E)\), where \(V\) is a set of vertices,
    \(E\) is a set of paired vertices that denotes the undirected edges 
    of the graph. 
\end{definition}

\begin{definition}[Labelling]
    \( \mathcal{L} : V \rightarrow K \), is a vertex labelling function 
    which maps vertices into arbitrary sets whose elements are the labels
    of the given node. Two vertices, \(u, v\) are equivalent if 
    \( \mathcal{L}(u) = \mathcal{L}(v) \).
\end{definition}

\begin{definition}[Isomorphism]
    \(G_1\) and \(G_2\) are isomorphic if a bijection exists between \(V_1\)
    and \(V_2\) such that two vertices are neighbours in \(G_1\) if and only
    if their respective pairs in \(G_2\) are neighbours, neighbouring 
    vertex pairs have the same number of edges between each other, and a
    vertex and its pair have the same labels.
\end{definition}

\begin{definition}[Subgraph]
    \(G_1\) is a subgraph of \(G_2\) if \(V_1 \subseteq V_2 \), \(E_1 \subseteq E_2\)
    and two vertices are neighbours in \(G_1\) only if they are neighbours in \(G_2\).
\end{definition}

\begin{definition}[Induced subgraph]
    If \(E_1\) consists of those edges from \(E_2\) whose both vertices are in
    \(V_1\), and \(E_1\) contains all these edges, then \(G_1\) is an induced
    subgraph of \(G_2\).
\end{definition}

\begin{definition}[Subgraph isomorphism]
    \(G_1\) is subgraph isomorphic to \(G_2\) if \(G_1\) is isomorphic to any
    subgraphs of \(G_2\).
\end{definition}

\begin{definition}[Induced subgraph isomorphism]
    \(G_1\) is induced subgraph isomorphic to \(G_2\) if \(G_1\) is isomorphic to any
    induced subgraphs of \(G_2\). Throughout this paper, we refer to induced subgraph
    isomorphism with the term of subgraph isomorphism. $M(q, G)$ denotes the set of 
    mappings found by an arbitrary subgraph isomorphism algorithm.
\end{definition}

\begin{definition}
    An injection $m : D \rightarrow V_G$ is called a (partial) mapping, where $D \subseteq V_q$.
\end{definition}

\begin{definition}
    $m_q$ and $m_G$ denotes the domain and the range of m respectively.
\end{definition}

\begin{definition}
    A mapping $m$ covers a node $u \in V_q \cup V_G$ if $u \in m_q \cup m_G$.
\end{definition}

\begin{definition}
    A mapping $m$ is a whole mapping if it covers all the nodes of $V_q$.
\end{definition}


This paper concentrates on the induced subgraph isomorphism problem in dynamic graphs, 
i.e. graphs that change with time. After finding the initial matches given a query graph
\(q\) and a data graph \(G\), keep the set of matches up to date in response to small 
updates \(\Delta G \) on \(G\) without recomputing all matches from scratch. \(\Delta G\) 
can be one of the following operations:
\begin{itemize}
    \item add a new node to \(G\),
    \item remove an existing node from \(G\),
    \item add an edge between two nodes of \(G\) and
    \item remove an existing edge between two nodes of \(G\).
\end{itemize}

\section{Algorithms}

This section gives a brief overview on how the two algorithms of interest (DAF and VF2++)
work.

\subsection{VF2}

Since VF2++ is an extension over VF2, first, we describe how VF2 works. It is a recursive 
algorithm where each state of the matching process can be associated with a partial mapping
$m$. VF2 starts with an empty mapping \todo{describe mappings in a section above this one} and it 
gradually extends it until a whole mapping is reached. For the current mapping $m$, it calculates a 
candidate set of $(u, v)$ pairs to be included in $m$. It iterates over the
$(u, v)$ elements of the candidate set, and if $\mathcal{F}(m, (u, v))$ is feasible then it recursively 
tries to extend $m'$, where $\mathcal{F}$ is the feasibility function and $m'$ is a partial mapping
obtained by adding $(u, v)$ to $m$.

\begin{definition}
    Let $m$ be a mapping. $Cons(m, (u, v))$ is a logical consistency function which is true if and only if $m$
    satisfies the requirements of induced subgraph isomorphism considering $q_m$ and $G_m$, where
    $q_m$ and $G_m$ are the subgraphs of $q$ and $G$ induced by $m_q$ and $m_G$
    respectively. $Cons$ is used to verify that the consistency of $m$ also holds after extended with $(u, v)$.
\end{definition}

\begin{definition}
    Let $m$ be a mapping. $Cut(m)$ is a logical cutting function which is false if there exists a 
    sequence of extensions of $m$ for which the resulting mapping is whole and it satisfies the
    requirements of induced subgraph isomorphism. $Cut$ is used to determine if the current partial 
    mapping is not contained in any whole mapping, thus trying to extend it would be useless.
\end{definition}

\begin{definition}
    The feasibility function $\mathcal{F}$ is defined as follows: 
    
    $\mathcal{F}(m, (u, v)) = Cons(m, (u, v)) \land \neg Cut(m)$.
\end{definition}

The feasibility function ensures that the algorithm considers only $(u, v)$ candidates such that 
$m$ extended with $(u, v)$ remains consistent, and it eliminates the need of processing partial
mappings for which it can be proven that they cannot be extended to a whole mapping.

\begin{algorithm}[h]
    \SetAlgoLined\DontPrintSemicolon
    \SetKwFunction{proc}{vf2}
    \SetKwProg{myproc}{Procedure}{}{}
    \myproc{\proc{m}}{
        \uIf(){$m$ covers $V_q$}{
            \nl Output(m)\;
        }
        \Else{
            \nl $P_m$ $\gets$ the candidate set of pairs for extending $m$\;
            \ForEach(){$(u, v) \in P_m$}{
                \uIf(){$\mathcal{F}(m, (u, v))$}{
                    \nl \proc(extend($m, (u,v)$))\;
                }
            }
        }        
    }
    \caption{VF2 algorithm}
\end{algorithm}

Let $T_q(m) := {u \in V_q \ m_q: \exists u' \in m_q: (u, u') \in E_q}$, and
$T_G(m) := {v \in V_G \ m_G: \exists v' \in m_G: (v, v') \in E_G}$.

The candidate set for extending $m$ is $P_m$. $P_m$ consists of the pairs of uncovered neighbors
of covered nodes. If there exists no such pair, $P_m$ contains all uncovered nodes. Formally,

\[
    P_m = 
\begin{cases}
    T_q(m) \times T_G(m),& \text{if} T_q(m) \neq \emptyset \text{and} T_G(m) \neq \emptyset\\
    (V_q \setminus m_q) \times (V_G \setminus m_G),  & \text{otherwise}.
\end{cases}    
\]


\subsection{VF2++}

VF2++ \todo{cite} was published by Alp\'{a}r J\"{u}ttner and P\'{e}ter Madarasi in 2018.
The algorithm makes performance improvements compared to VF2 by calculating a matching
order, in which the vertices of $q$ are processed in a partial mapping, and by applying
a more efficient cutting function.

The order of the nodes of $q$ to be matched have a huge impact on the number of visited
states. In case of VF2, the lack of strictly defined matching order can lead to evaluating
states that cannot be wholly extended, only to realize this deep down on the search tree.
By choosing a proper matching order, one can eliminate such unnecessary computations earlier.

\todo{example}

The first step of VF2++ is determining the matching order in which the algorithm will process
the vertices of the query graph $q$. During the order's computation, VF2++ takes into account
the structure of $q$ and its labeling. First, it chooses a node with the least common label 
and with the largest degree. This node will be the root of a tree, which will be used to determine
the final matching order $\mathcal{O}$.


\[ root = {r | r \in \argmax_{deg}(\argmin_{label_{\mathcal{O}}}(V_q \setminus \mathcal{O}))} \]
, where $label_{\mathcal{O}}(n) := |{v \in V_G : \mathcal{L}(n) = \mathcal{L}(v)}| - |{u \in \mathcal{O}: \mathcal{L}(n) = \mathcal{L}(u)}|$, 
i.e. it computes the difference between the number of vertices in $G$ with the label of $n$ and 
the number of vertices in $\mathcal{O}$ with the label of $n$. Next, the algorithm computes a tree 
$T$ by traversing $q$ in BFS (Breadth first search) order from the previously calculated root, and
it processes each level of $T$ the following way. Let $V_{q,d}$ denote the set of vertices of $T$ in
depth $d$. The process selects the vertices with the largest connectivity respect to $\mathcal{O}$,
i.e. those nodes whose number of neighbors that are already in $\mathcal{O}$ is the largest. Then
from these nodes, it selects the ones with the largest degree, then those with the rarest label.

\[ o = {u | u \in \argmin_{label_{\mathcal{O}}}(\argmax_{deg}(\argmax_{conn}(V_{q,d})))} \]

The selected node $o$ is appended to $\mathcal{O}$, and it is removed from $V_{q,d}$. This continues 
until $V_{q,d}$ has no more elements. Algorithm \ref{alg:vf2pporder} and \ref{alg:vf2ppproc} describe
the matching order procedures on a high level.

\begin{algorithm}[h]
    \SetAlgoLined\DontPrintSemicolon
    \SetKwFunction{proc}{vf2\_order}
    \SetKwFunction{process}{process}
    \SetKwProg{myproc}{Procedure}{}{}
    \myproc{\proc{}}{
        \nl $\mathcal{O} := \emptyset$\;
        \While(){$V_q \setminus \mathcal{O} \neq \emptyset$}{
            \nl $r \in \argmax_{deg}(\argmin_{label_{\mathcal{O}}}(V_q \setminus \mathcal{O}))$\;
            \nl $T$ $\gets$ \text{BFS}$(r)$\;
            \ForEach(){$d = 0,1,\cdots depth(T)$}{
                \nl $V_{q,d} := $ \text{nodes of the} $d$\text{-th level}\;
                \nl \process{$V_q,d$}\;
            }
        }           
    }
    \label{alg:vf2pporder}
    \caption{VF2++ order}
\end{algorithm}

\begin{algorithm}[h]
    \SetAlgoLined\DontPrintSemicolon
    \SetKwFunction{proc}{process}
    \SetKwProg{myproc}{Procedure}{}{}
    \myproc{\proc{$V_{q,d}$}}{
        \While(){$V_{q,d} \neq \emptyset$}{
            \nl $o \in \argmin_{label_{\mathcal{O}}}(\argmax_{deg}(\argmax_{conn}(V_{q,d})))$\;
            \nl $V_{q,d}$ $\gets$ $V_{q,d} \setminus o$\;
            \nl $\mathcal{O}$.append($o$)\;
        }        
    }
    \label{alg:vf2ppproc}
    \caption{VF2++ process the d-th level of $T$}
\end{algorithm}

VF2++'s additional changes to the original include a refined way of determining the candidates
of $u \in V_q$ and applying cutting rules on them. In this version, $u \in q$'s candidates will be 
$v \in G$ that are in the neighborhood of $m_G$, are not covered yet and are consistent with $m$.

\[ P_m(u) = {v \in G | \neg covered_m(v) \land \forall u' \in q: (u, u') \in E_q \land u' \in m_q \iff (v, m(u')) \in E_G}  \]

VF2++ also introduces a new cutting rule which verifies that for a given candidate pair $(u, v)$,
$v$ in $G$ has at least as many neighbors with the appropriate labels as $u$ in $q$.

\todo{example}

\subsubsection{DAF}